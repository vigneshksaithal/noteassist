{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { LLMMessage, ChatOpenAIParams, HighlightEvent, HighlightContext } from './types'\nimport { z } from 'zod'\nimport { zodToJsonSchema } from 'zod-to-json-schema'\n\nexport * from './types'\n\n/**\n * The entire exported Highlight API, available within your Highlight app.\n */\nexport interface HighlightAPI {\n  /**\n   * A secure store for your app to save data.\n   */\n  appStorage: {\n    isHydrated: () => boolean\n    whenHydrated: () => Promise<boolean>\n    all: () => Record<string, any>\n    get: (key: string) => any\n    set: (key: string, value: any) => void\n    setAll: (value: Record<string, any>) => void\n    delete: (key: string) => void\n    clear: () => void\n  }\n\n  app: {\n    /**\n     * Check if the user has created a desktop shortcut for your app.\n     * @param appSlug\n     */\n    hasDesktopShortcut: () => Promise<boolean>\n\n    /**\n     * Prompt the user to create a desktop shortcut for your app.\n     */\n    requestCreateDesktopShortcut: () => Promise<void>\n\n    /**\n     * Tell Highlight your app should run in the background.\n     * If you don't have permission to run in the background, this will throw an error.\n     * @see Highlight.permissions.requestBackgroundPermission\n     */\n    setBackgroundStatus: (status: boolean) => Promise<void>\n\n    /**\n     * Show a notification to the user.\n     * @param title The title of the notification.\n     * @param body The body of the notification.\n     */\n    showNotification: (title: string, body: string) => void\n\n    /**\n     * Get the hotkey the user should use to bring up the Highlight overlay window.\n     * This is useful when onboarding users to show them how to activate your app.\n     */\n    getHotkey: () => Promise<string>\n\n    /**\n     * Adds an event listener for your Highlight app.\n     * @param event The name of the event to listen for.\n     * @param listener The listener Highlight will call when the event is emitted.\n     * @returns A function to remove the listener when you are done with it\n     */\n    addListener: (event: HighlightEvent, listener: (...args: any[]) => void) => () => void\n\n    /**\n     * Open a Highlight app\n     * @param appId - The ID of the app to open\n     * @returns A promise that resolves when the app is opened\n     */\n    openApp: (appId: string) => Promise<void>\n  }\n\n  permissions: {\n    /**\n     * Request permission to run your app in the background when Highlight starts.\n     */\n    requestBackgroundPermission: () => Promise<boolean>\n    /**\n     * Request permission to read the contents of the user's clipboard.\n     */\n    requestClipboardReadPermission: () => Promise<boolean>\n    /**\n     * Request permission to capture screenshots of the user's displays and windows\n     */\n    requestScreenshotPermission: () => Promise<boolean>\n    /**\n     * Request permission to capture the contents of the user's windows\n     */\n    requestWindowContextPermission: () => Promise<boolean>\n  }\n\n  user: {\n    /**\n     * Get the facts the user has set for themselves. This could be \"I only want concise responses\", \"my name is...\", etc.\n     */\n    getFacts: () => Promise<string[]>\n    /**\n     * Set the ASR to run in realtime (1.1 seconds). This will use about 10x more GPU processing than non realtime, so once you are finished needing realtime transcripton, you should also set this to false\n     * @param {boolean} isActive\n     */\n    setAsrRealtime: (isActive: boolean) => void\n    /**\n     * Get the audio captions from the user's device.\n     * @param {boolean} longAudio - If you want to get the long audio captions. Fetch ASR text for the last 2 hours\n     * @returns {string} - The audio captions.\n     */\n    getAudio: (longAudio: boolean) => Promise<string>\n\n    /**\n     * Get the audio captions from the user's device for the specified duration.\n     * @param {number} duration - The duration in seconds for which you want to get the audio captions.\n     * @returns {string} - The audio captions.\n     */\n    getAudioForDuration: (duration: number) => Promise<string>\n\n    /**\n     * Get the microphone activity as a number from 0-5. 0 means no audio, 5 means absolute loudest.\n     * @param {number} lastNumMs - specifies the duration in milliseconds for which you want to calculate the average energy of the mic input.\n     * @returns {number} - The microphone activity from 0-5.\n     */\n    getMicActivity: (lastNumMs: number) => Promise<number>\n    /*\n     * Get screenshot of the user's screen.\n     * @returns {string} - Base64 encoded screenshot.\n     */\n    getScreenshot: () => Promise<string>\n\n    /**\n     * Get an email address for the user, for privacy, this address will forward to the user's real email address.\n     * @returns {string} - The email address.\n     */\n    getEmail: () => Promise<string>\n\n    /**\n     * Fetches the context of the window (ignoring Highlight), the same as the eventListener \"onContext\".\n     * May be polled for repeated updates.\n     */\n    getContext: (paneDetectionEnabled?: boolean) => Promise<HighlightContext>\n\n    /**\n     * Get the contents of the clipboard.\n     * @returns {{ type: 'image' | 'text'; value: string }} - The type and value of the contents of the clipboard\n     */\n    getClipboardContents: () => Promise<{ type: 'image' | 'text'; value: string } | undefined>\n\n    /**\n     * @returns {Array<{ thumbnail: string }>} - An array of base64 encoded screenshots of the user's displays.\n     */\n    getDisplayScreenshots: () => Promise<{ thumbnail: string }[]>\n\n    /**\n     * Gets the titles and app icons of the user's open windows\n     * @returns {Array<{ windowTitle: string; appIcon?: string }>} - An array of window titles and app icons.\n     */\n    getWindows: () => Promise<{ windowTitle: string; appIcon?: string }[]>\n\n    /**\n     * Get a screenshot of a specific window.\n     * @param {string} windowTitle - The title of the window to screenshot. This is the same as the window title you get from getWindows.\n     * @returns {string} - Base64 encoded screenshot of the window.\n     */\n    getWindowScreenshot: (windowTitle: string) => Promise<string>\n\n    /**\n     * Get the context of a specific window\n     * @param {string} windowTitle - The title of the window to get the context of.\n     * @returns {HighlightContext} - The context of the window.\n     */\n    getWindowContext: (windowTitle: string) => Promise<HighlightContext>\n  }\n\n  vectorDB: {\n    /**\n     * Create a table in the vector database.\n     * @param tableName\n     * @returns\n     */\n    createTable: (tableName: string) => Promise<void>\n\n    /**\n     * Insert an item into a table in the vector database.\n     * @param tableName\n     * @param text\n     * @returns\n     */\n    insertItem: (tableName: string, text: string, metadata: object) => Promise<void>\n\n    /**\n     * Get all items in a table in the vector database.\n     * @param tableName\n     * @returns\n     */\n    getAllItems: (tableName: string) => Promise<any[]>\n\n    /**\n     * Update text for an item in a table in the vector database.\n     * @param tableName\n     * @param id\n     * @param text\n     * @param metadata\n     * @returns\n     */\n    updateText: (tableName: string, id: string, text: string, metadata: object) => Promise<void>\n\n    /**\n     * Update metadata for an item in a table in the vector database.\n     * @param tableName\n     * @param id\n     * @param metadata\n     * @returns\n     */\n    updateMetadata: (tableName: string, id: string, metadata: object) => Promise<void>\n\n    /**\n     * Search for items in a table in the vector database.\n     * @param tableName\n     * @param text\n     * @param maxResults\n     * @returns\n     */\n    search: (tableName: string, text: string, maxResults: number) => Promise<any[]>\n\n    /**\n     * Delete an item from a table in the vector database.\n     * @param tableName\n     * @param id\n     * @returns\n     */\n    deleteItem: (tableName: string, id: string) => Promise<void>\n\n    /**\n     * Delete a table from the vector database.\n     * @param tableName\n     * @returns\n     */\n    deleteTable: (tableName: string) => Promise<void>\n  }\n\n  auth: {\n    /**\n     * Get an access token and refresh token that can be used to validate the user's session on your backend.\n     */\n    signIn: () => Promise<{\n      accessToken: string\n      refreshToken: string\n    }>\n  }\n\n  inference: {\n    /**\n     * @returns {boolean} - Whether the user's device is capable of running a Small Language Model.\n     */\n    isSlmCapable: () => Promise<boolean>\n    /**\n     * Get a text prediction from a locally running Small Language Model(SLM).\n     * @param messages The messages to send to the SLM.\n     * @param grammar The grammar in GBNF format to send to the SLM.\n     * @returns A text prediction.\n     */\n    getTextPredictionSlm: (messages: LLMMessage[], grammar?: string) => Promise<string>\n    /**\n     * Get a stream of text predictions from an LLM.\n     * @param messages The messages to send to the LLM.\n     * @returns A stream of text predictions.\n     */\n    getTextPrediction: (messages: LLMMessage[], params?: ChatOpenAIParams) => AsyncGenerator<string>\n\n    /**\n     * Get a stream of structured text predictions from an LLM.\n     * @param structure The Zod structure the output should be in\n     */\n    getStructuredTextPrediction<T>(\n      structure: z.ZodType<T>,\n      messages: LLMMessage[],\n      params?: ChatOpenAIParams,\n    ): AsyncGenerator<T>\n  }\n\n  /**\n   * Adds an event listener for your Highlight app.\n   * @param event The name of the event to listen for.\n   * @param listener The listener Highlight will call when the event is emitted.\n   * @deprecated use `Highlight.app.addListener` instead\n   */\n  addEventListener: (event: HighlightEvent, listener: (...args: any[]) => void) => void\n\n  /**\n   * Removes an event listener that you previously registered.\n   * @deprecated use `Highlight.app.addListener` instead, and call the return value to remove the listener\n   */\n  removeEventListener: (event: HighlightEvent, listener: (...args: any[]) => void) => void\n\n  /**\n   * Adds an event listener for your Highlight app that will only fire once.\n   * @deprecated use `Highlight.app.addListener` instead, and call the return value to remove the listener after you've used it\n   */\n  once: (event: HighlightEvent, listener: (...args: any[]) => void) => void\n\n  /**\n   * Check if your app is running in Highlight.\n   */\n  isRunningInHighlight: () => boolean\n}\n\n/**\n * Define extra methods/props that aren't for the end consumers of the API, just for this package and the preload script.\n */\ninterface InternalHighlightAPI extends HighlightAPI {\n  internal: {\n    getTextPrediction: (messages: LLMMessage[], params?: ChatOpenAIParams) => Promise<number>\n    getStructuredTextPrediction: (structure: any, messages: LLMMessage[], params?: ChatOpenAIParams) => Promise<number>\n  }\n}\n\n/**\n * Gets the Highlight API by accessing `globalThis.highlight`.\n * @throws an error if the caller is not within a Highlight app.\n */\nfunction getHighlightAPI(): InternalHighlightAPI {\n  if (!globalThis) {\n    throw new Error(\n      'Your web app must be running in the Highlight app to use this module. Please see https://docs.highlight.ing for more details.',\n    )\n  }\n\n  // @ts-expect-error\n  if (globalThis.highlight === undefined) {\n    throw new Error(\n      'Your web app must be running in the Highlight app to use this module. Please see https://docs.highlight.ing for more details.',\n    )\n  }\n\n  // @ts-expect-error\n  return globalThis.highlight as HighlightAPI\n}\n\n/**\n * This function is used to turn the Highlight text prediction API into an AsyncGenerator pattern\n * that libraries like ChatGPT use.\n */\nfunction awaitNextTextPrediction(id: number): Promise<string | void> {\n  const api = getHighlightAPI()\n\n  return new Promise((resolve) => {\n    const updateDestructor = api.app.addListener('onTextPredictionUpdate', (message) => {\n      if (message.id !== id) {\n        return\n      }\n\n      onDone(message.text)\n    })\n\n    const doneDestructor = api.app.addListener('onTextPredictionDone', (message) => {\n      if (message.id !== id) {\n        return\n      }\n\n      onDone('')\n    })\n\n    function onDone(text: string) {\n      updateDestructor()\n      doneDestructor()\n      resolve(text)\n    }\n  })\n}\n\nconst api: HighlightAPI = {\n  appStorage: {\n    isHydrated: () => getHighlightAPI().appStorage.isHydrated(),\n    whenHydrated: () => getHighlightAPI().appStorage.whenHydrated(),\n    all: () => getHighlightAPI().appStorage.all(),\n    get: (key) => getHighlightAPI().appStorage.get(key),\n    set: (key, value) => getHighlightAPI().appStorage.set(key, value),\n    setAll: (value) => getHighlightAPI().appStorage.setAll(value),\n    delete: (key) => getHighlightAPI().appStorage.delete(key),\n    clear: () => getHighlightAPI().appStorage.clear(),\n  },\n  app: {\n    hasDesktopShortcut: () => getHighlightAPI().app.hasDesktopShortcut(),\n    requestCreateDesktopShortcut: () => getHighlightAPI().app.requestCreateDesktopShortcut(),\n    setBackgroundStatus: (status) => getHighlightAPI().app.setBackgroundStatus(status),\n    showNotification: (title, body) => getHighlightAPI().app.showNotification(title, body),\n    getHotkey: () => getHighlightAPI().app.getHotkey(),\n    addListener: (event, listener) => getHighlightAPI().app.addListener(event, listener),\n    openApp: (appId) => getHighlightAPI().app.openApp(appId),\n  },\n  permissions: {\n    requestBackgroundPermission: () => getHighlightAPI().permissions.requestBackgroundPermission(),\n    requestClipboardReadPermission: () => getHighlightAPI().permissions.requestClipboardReadPermission(),\n    requestScreenshotPermission: () => getHighlightAPI().permissions.requestScreenshotPermission(),\n    requestWindowContextPermission: () => getHighlightAPI().permissions.requestWindowContextPermission(),\n  },\n  user: {\n    getFacts: () => getHighlightAPI().user.getFacts(),\n    getAudio: (longAudio: boolean) => getHighlightAPI().user.getAudio(longAudio),\n    getAudioForDuration: (duration: number) => getHighlightAPI().user.getAudioForDuration(duration),\n    setAsrRealtime: (isActive) => getHighlightAPI().user.setAsrRealtime(isActive),\n    getMicActivity: (lastNumMs) => getHighlightAPI().user.getMicActivity(lastNumMs),\n    getScreenshot: () => getHighlightAPI().user.getScreenshot(),\n    getEmail: () => getHighlightAPI().user.getEmail(),\n    getContext: (paneDetectionEnabled?: boolean) => getHighlightAPI().user.getContext(paneDetectionEnabled),\n    getClipboardContents: () => getHighlightAPI().user.getClipboardContents(),\n    getDisplayScreenshots: () => getHighlightAPI().user.getDisplayScreenshots(),\n    getWindows: () => getHighlightAPI().user.getWindows(),\n    getWindowScreenshot: (windowTitle) => getHighlightAPI().user.getWindowScreenshot(windowTitle),\n    getWindowContext: (windowTitle) => getHighlightAPI().user.getWindowContext(windowTitle),\n  },\n  vectorDB: {\n    createTable: (tableName) => getHighlightAPI().vectorDB.createTable(tableName),\n    insertItem: (tableName, text, metadata) => getHighlightAPI().vectorDB.insertItem(tableName, text, metadata),\n    getAllItems: (tableName) => getHighlightAPI().vectorDB.getAllItems(tableName),\n    updateText: (tableName, id, text, metadata) => getHighlightAPI().vectorDB.updateText(tableName, id, text, metadata),\n    updateMetadata: (tableName, id, metadata) => getHighlightAPI().vectorDB.updateMetadata(tableName, id, metadata),\n    search: (tableName, text, maxResults) => getHighlightAPI().vectorDB.search(tableName, text, maxResults),\n    deleteItem: (tableName, id) => getHighlightAPI().vectorDB.deleteItem(tableName, id),\n    deleteTable: (tableName) => getHighlightAPI().vectorDB.deleteTable(tableName),\n  },\n  auth: {\n    signIn: () => getHighlightAPI().auth.signIn(),\n  },\n  inference: {\n    isSlmCapable: () => getHighlightAPI().inference.isSlmCapable(),\n    getTextPredictionSlm: (messages: LLMMessage[], grammar?: string) =>\n      getHighlightAPI().inference.getTextPredictionSlm(messages, grammar),\n    getTextPrediction: async function* (messages: LLMMessage[], params?: ChatOpenAIParams) {\n      const api = getHighlightAPI()\n\n      const id = await api.internal.getTextPrediction(messages, params)\n\n      let done = false\n\n      const destructor = api.app.addListener('onTextPredictionDone', (message) => {\n        if (message.id !== id) {\n          return\n        }\n\n        done = true\n      })\n\n      while (!done) {\n        const next = await awaitNextTextPrediction(id)\n        if (next) {\n          yield next\n        }\n      }\n\n      destructor()\n    },\n    getStructuredTextPrediction: async function* <T>(\n      structure: z.ZodType<T>,\n      messages: LLMMessage[],\n      params?: ChatOpenAIParams,\n    ) {\n      const api = getHighlightAPI()\n\n      // Generate the OpenAPI schema from the Zod schema\n      const openApiSchema = zodToJsonSchema(structure)\n\n      const id = await api.internal.getStructuredTextPrediction(openApiSchema, messages, params)\n\n      let done = false\n\n      const destructor = api.app.addListener('onTextPredictionDone', (message) => {\n        if (message.id !== id) {\n          return\n        }\n\n        done = true\n      })\n\n      while (!done) {\n        const next = await awaitNextTextPrediction(id)\n        if (next) {\n          yield next as T\n        }\n      }\n\n      destructor()\n    },\n  },\n  addEventListener: (event: HighlightEvent, listener: (...args: any[]) => void) => {\n    getHighlightAPI().addEventListener(event, listener)\n  },\n  removeEventListener: (event: HighlightEvent, listener: (...args: any[]) => void) => {\n    getHighlightAPI().removeEventListener(event, listener)\n  },\n\n  once: (event: HighlightEvent, listener: (...args: any[]) => void) => {\n    getHighlightAPI().once(event, listener)\n  },\n\n  isRunningInHighlight: () => {\n    // @ts-expect-error\n    return globalThis.highlight !== undefined\n  },\n}\n\nexport default api\n"],"mappings":"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","names":["api"]}